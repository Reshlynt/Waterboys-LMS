Course Introduction and Welcome:\n 
Welcome to Introduction to Python course!\n
In this course, we will learn the basics of Python programming language and how to use it to solve various problems.\n
Throughout the course, we will cover topics such as data types, variables, operators, control structures, functions, file input/output, object-oriented programming, and working with libraries and modules.\n
We will also explore more advanced topics such as working with APIs, web scraping, and automation. By the end of the course, you will have a solid understanding of Python programming language and the skills to apply it to real-world projects.\n

Course Objectives and Outcomes: The learning objectives and expected outcomes of the course, including what students will be able to do or know after completing the course.
done

Course Outline and Schedule: A detailed breakdown of the course outline and schedule, including the number of lessons, duration of each lesson, and any assignments or assessments.


A variable is like a container for information: it stores values of different types depending on the use case.
Variables are really important in programming because this storage of data allows use later in the program.


Type conversion, also known as casting, refers to the process of converting one data type to another.\nIn Python, you can convert between primitive data types using built-in functions such as int(), float(), str(), and bool().\nFor example, you can use int() to convert a string containing a number to an integer, or float() to convert an integer or string to a floating-point number.\nSimilarly, you can use str() to convert a number to a string, or bool() to convert a value to either True or False.\nIt's important to note that some conversions may result in a loss of precision or information, so it's always best to use the appropriate conversion function for the desired result.

"# Converting a string to an integer:\nage_str = '27'\nage_int = int(age_str)\nprint(age_int)  # Output: 27\n\n# Converting a float to an integer:\nprice_float = 9.99\nprice_int = int(price_float)\nprint(price_int)  # Output: 9\n\n# Converting an integer to a string:\ncount_int = 10\ncount_str = str(count_int)\nprint(count_str)  # Output: "10"\n\n# Converting a boolean to an integer:\nis_true = True\nis_false = False\nint_true = int(is_true)\nint_false = int(is_false)\nprint(int_true)   # Output: 1\nprint(int_false)  # Output: 0\n\n# Converting a string to a boolean:\nis_true_str = "True"\nis_false_str = "False"\nbool_true = bool(is_true_str)\nbool_false = bool(is_false_str)\nprint(bool_true)   # Output: True\nprint(bool_false)  # Output: True (any non-empty string is considered True)



# Example 1: if statement\nx = 7\nif x > 5:\n    print("x is greater than 5")\n\n# Example 2: if-else statement\nx = 2\nif x > 5:\n    print("x is greater than 5")\nelse:\n    print("x is less than or equal to 5")\n\n# Example 3: if-elif-else statement\nx = 12\nif x < 5:\n    print("x is less than 5")\nelif x > 10:\n    print("x is greater than 10")\nelse:\n    print("x is between 5 and 10")\n\nThe following code outputs:\nx is greater than 5\nx is less than or equal to 5\nx is greater than 10


# Example 1: For loop\nnumbers = [1, 2, 3, 4, 5]\nfor num in numbers:\n    print(num)\n# Output: 1 2 3 4 5\n\nword = "hello"\nfor letter in word:\n    print(letter)\n# Output: h e l l o\n\n# Example 2: While loop\ni = 0\nwhile i < 5:\n    print(i)\n    i += 1\n# Output: 0 1 2 3 4\n# Example 3: Range function with for loop\nfor i in range(5):\n    print(i)\n# Output: 0 1 2 3 4\n\n# Example 4: Enumerate function with for loop\nfruits = ["apple", "banana", "cherry"]\nfor i, fruit in enumerate(fruits):\n    print(i, fruit)\n# Output: 0 apple 1 banana 2 cherry\n\n# Example 5: Zip function with for loop\nnames = ["Alice", "Bob", "Charlie"]\nages = [25, 30, 35]\nfor name, age in zip(names, ages):\n    print(name, age)\n# Output: Alice 25 Bob 30 Charlie 35\n\n# Example 6: Break statement in for loop\nnumbers = [1, 2, 3, 4, 5]\nfor num in numbers:\n    if num == 3:\n        break\n    print(num)\n# Output: 1 2\n\n# Example 7: Continue statement in for loop\nnumbers = [1, 2, 3, 4, 5]\nfor num in numbers:\n    if num == 3:\n        continue\n    print(num)\n# Output: 1 2 4 5

In Python, logical operators are used to evaluate logical expressions and return a boolean value of either True or False.\nThere are three logical operators in Python: \"and\", \"or\", and \"not\".\nThe \"and\" operator returns True if both expressions being evaluated are True, otherwise it returns False.\nThe \"or\" operator returns True if at least one of the expressions being evaluated is True, otherwise it returns False.\nFinally, the \"not\" operator returns the opposite boolean value of the expression it is evaluating.\nLogical operators are often used in conditional statements such as \"if\" statements and \"while\" loops to control program flow based on logical conditions.\nThey can also be used in conjunction with comparison operators to create more complex logical expressions.\nOverall, logical operators are an essential tool for writing programs that can make decisions based on logical conditions. Here are some examples:\na = 5\nb = 10\nc = 15\n\n# using AND operator\nif a < b and b < c:\n    print(\"Both conditions are true.\")\n# output: Both conditions are true.\n\n# using OR operator\nif a < b or a > c:\n    print(\"At least one condition is true.\")\n# output: At least one condition is true.\n\n# using NOT operator\nif not(a > b):\n    print(\"a is not greater than b.\")\n# output: a is not greater than b.

A function is defined using the "def" keyword, followed by the function name and parentheses.\nInside the parentheses, you can define parameters for the function to take as input.\nThe body of the function is indented and contains the code to be executed when the function is called.\nTo call a function, you simply need to write the function name followed by parentheses, and pass any necessary arguments inside the parentheses.\nFunctions can also return values using the "return" keyword.\nHere are some examples:\n# Function that prints a welcome message with a name parameter\ndef welcome(name):\n    print(f"Welcome, {name}!")\n\n# Function that calculates the sum of two numbers with two parameters\ndef add_numbers(num1, num2):\n    sum = num1 + num2\n    return sum\n\n# Call the welcome function with the name parameter "Alice"\nwelcome("Alice") #Output: Welcome, Alice!\n\n# Call the add_numbers function with the parameters 3 and 5, and print the result\nresult = add_numbers(3, 5)\nprint(f"The sum of 3 and 5 is: {result}") #Output: The sum of 3 and 5 is: 8

Python has a large number of built-in modules that provide useful functionality out of the box.\nThese modules are pre-written code libraries that extend the capabilities of Python and can be imported into programs.\nSome of the commonly used built-in modules include math, os, sys, random, and datetime.\nThe math module provides functions for mathematical operations such as trigonometric functions, logarithms, and constants such as pi and e.\nThe os and sys modules provide functions for interacting with the operating system, such as file operations, environment variables, and system configuration.\nThe random module provides functions for generating random numbers and selecting random elements from sequences.\nThe datetime module provides classes for working with dates and times, such as calculating time differences and formatting dates for display.\nOverall, the built-in modules provide a wide range of functionality and can greatly simplify the development process for many applications.\nHere are some examples:\n

\nimport datetime\n\ncurrent_time = datetime.datetime.now()\nprint("Current date and time: ", current_time) #Output: Current date and time: 2023-25-03 13:45:32.123456\n\nimport random\n\nrandom_number = random.randint(1, 10)\nprint("Random number between 1 and 10: ", random_number) #Output: Random number between 1 and 10: 8\n\nimport math\na = 16\nprint(math.sqrt(a))  # Output: 4.0


Data structures in Python are the building blocks of programming.\nThey are essential for managing and manipulating data in a way that is both efficient and effective.\nData structures can range from simple to complex, depending on the task at hand.\nIn Python, there are several built-in data structures, such as lists, tuples, sets, and dictionaries, that can be used to store and organize data.\nEach of these structures has its unique characteristics and uses, which we will explore in this class.\nBy the end of this lesson, you should have a solid understanding of data structures and be able to use them in your Python programs to make your code more efficient and effective.

A list is an ordered collection of items, where each item is assigned a unique index number that can be used to access and manipulate the data.\nIn Python, lists are a versatile and widely used data structure, and they can be created using square brackets and separating each item with a comma.\nLists can contain items of different types, including strings, numbers, and even other lists.\nThey are commonly used for storing and manipulating data that can change over time, such as user input or database records.\nWith their flexibility and powerful built-in functions, lists are an essential tool for many programming tasks in Python.\nHere are some examples of their uses\nA class roster:\nstudents = ['Alice', 'Bob', 'Charlie', 'David']\nprint(students[0]) #Output: 'Alice'\nprint(students[3]) #Output: 'David'\n\nFruits(adding and removing elements):\nfruits = ['apple', 'date', 'cherry']\nfruits.append('mango')#adding an element\nprint(fruits)# Output: ['apple', 'date', 'cherry', 'mango']\nfruits.remove('apple')\nprint(fruits)#Output: ['date', 'cherry', 'mango']

In Python, tuples and sets are two other types of data structures that are commonly used. A tuple is an ordered, immutable collection of objects. This means that once a tuple is created, its contents cannot be modified. Tuples are often used to group related data together, such as a coordinate pair or a date and time. Tuples are created by enclosing a comma-separated sequence of objects in parentheses.

On the other hand, a set is an unordered collection of unique objects.\nUnlike lists and tuples, sets do not have a specific order, and duplicate elements are automatically removed.\nSets are useful for tasks such as removing duplicates from a list or testing membership of an element in a collection.\nSets are created by enclosing a comma-separated sequence of objects in curly braces or by using the set() function.\nHere is an example showing the functionality of a tuple:\n\n# creating a tuple of numbers\nmy_tuple = (1, 2, 3, 4, 5)\n\n# accessing elements of a tuple\nprint(my_tuple[0]) # output: 1\nprint(my_tuple[3]) # output: 4\n\n# attempting to modify a tuple (this will result in an error)\nmy_tuple[2] = 10 # TypeError: 'tuple' object does not support item assignment\n\nHere is an example using a set:\n# creating a set of strings\nmy_set = {"apple", "banana", "cherry", "apple", "banana"}\n\n# printing the set (duplicates are automatically removed)\nprint(my_set) # output: {"apple", "banana", "cherry"}\n\n# adding an item to the set\nmy_set.add("orange")\n\n# removing an item from the set\nmy_set.remove("banana")\n\n# checking if an item exists in the set\nprint("orange" in my_set) # output: True\nprint("watermelon" in my_set) # output: False

\npeopleNumbers = {\"Alice\":\"123 456 7890\",\"Bob\":\"098 765 4321\"}\nprint(peopleNumbers[\"Alice\"]) # Output: 123 456 7890\nprint(peopleNumbers.get(\"Bob\")) # Output: 098 765 4321
\npeopleNumbers[\Jake\"] = \"981 235 0124\"\nprint(peopleNumbers)#Output: {\"Alice\":\"123 456 7890\",\"Bob\":\"098 765 4321\", \"Jake\":\"981 235 0124\"}

Reading and writing to files is an essential part of many programming tasks, and Python provides several built-in functions to perform these operations.\nTo read data from a file, you first need to open the file using the open() function, specifying the file name and the mode in which you want to access the file (such as 'r' for reading or 'w' for writing).\nOnce the file is open, you can read its contents using the read() function, which returns the entire file's content as a string.\nAlternatively, you can read the file line by line using the readline() function.\nTo write data to a file, you need to open the file in write mode, using the 'w' flag.\nYou can then write data to the file using the write() function, which takes a string argument to write to the file.\nFinally, after reading from or writing to a file, you should always close the file using the close() function to ensure that any changes are properly saved and to free up system resources.\nWe will explore how exactly to do this in the following examples:\n\n# Open a file for writing to it\nwith open('example.txt', 'w') as f:\n    # Write some data to the file\n    f.write('Hello, world!\n')\n    f.write('This is an example file.\n')\n    f.close()\nThe file example.txt now contains the two lines 'Hello World' and 'This is an example file.'\n# Open a file for reading\nwith open('example.txt', 'r') as f:\n    # Read the contents of the file\n    contents = f.read() #Option 1, read entire file as 1 string\n    contents_list = f.readLines() #Option 2, seperate lines into individual strings stored in a list\n    content_one_line = f.readLine() #Option 3, reads one line at a time, the most inefficient way\n\n# Print the contents of the file\nprint(contents) #Output, single string containing everything\nprint(contents_list)#Output: lines comma seperated in a list\nprint(content_one_line)#Output: prints out the first line of the file

User input and output are essential components of any interactive Python program.\nOften times, software needs to be interactive(i.e. apps) and we need a way of handling input and output.\nHowever, we will cover it a much smaller scale than apps, so not to worry(Imagine coding an entire software application hahaha).\nThe input() function allows a program to accept user input from the keyboard, while the print() function is used to display output to the console or other output device. As you have noticed, we have using the print() function all along!\nThe input() function waits for the user to type something on the keyboard and press Enter, and returns a string containing the user's input.\nThe print() function takes one or more arguments and displays them on the console or other output device.\nThe format() method can be used to format strings to include variables or other data.\nIt is important to properly handle user input to prevent errors or security vulnerabilities, such as by validating input to ensure that it meets certain criteria.\nHere's an example that uses print(), input(), and format() to ask the user their name, age, and favorite color:\n\n# ask the user for their name, age, and favorite color\nname = input("What is your name? ")\nage = input("How old are you? ")\ncolor = input("What is your favorite color? ")\n\n# create a personalized message using the user's input\nmessage = "Hi {name}, I see that you're {age} years old and your favorite color is {color}. That's really cool!"\n\n# display the personalized message to the user\nprint(message.format(name=name, age=age, color=color))\n\nSo if I enter Vansh, 20, and red, the code should output Hi Vansh, I see that you're 20 years old and your favorite color is red. That's really cool!\nThis is a very basic chatbot, an interesting side project would be to make a madlibs type chatbot.

\nIn Python, errors that occur during program execution are known as exceptions.\nThese can arise due to a variety of reasons, such as incorrect input, unexpected data, or system failures.\nTo ensure that our programs handle these exceptions gracefully, we can use Python's built-in exception handling mechanism.\nThis involves enclosing the code that might raise an exception in a try block and using except blocks to catch and handle any specific types of exceptions that might occur.\nAdditionally, we can use the finally block to specify code that should be executed regardless of whether an exception occurred or not.\nBy handling exceptions in this way, we can prevent our programs from crashing unexpectedly and provide helpful error messages to users.\nWe can also use Python's logging module to log errors and other information about program execution, which can be useful for debugging and monitoring program behavior.\nKnowing how to handle exceptions is imperative when your code has to deal with situations that can cause a lot of problems (for example, reading or writing from a file).\nHere's an example that tries to take two numbers as user input, and tries to divide them:\n2try:\n    num1 = int(input("Enter a number: "))\n    num2 = int(input("Enter another number: "))\n    result = num1 / num2\n    print("The result is:", result)\nexcept ValueError:\n    print("Invalid input. Please enter a valid integer.")\nexcept ZeroDivisionError:\n    print("Cannot divide by zero.")\nfinally:\n    print("Exiting program.")

Object-Oriented Programming (OOP) is a programming strategy that is based on the concept of objects.\nIn Python, everything data type and structure is an object, making OOP a fundamental aspect of the language.\nOOP allows programmers to structure their code in a way that is more modular, flexible, and reusable.\nThis is accomplished through the creation of classes, which define the properties and behavior of objects, and the creation of instances of those classes, which are the actual objects themselves.\nPython provides a wide range of OOP features, including inheritance, encapsulation, and polymorphism, which allow programmers to build complex systems that are easy to maintain and extend.\nWith OOP in Python, programmers can write more organized and efficient code that is also reusable.\nThis is arguably why OOP the most important a skill a developer/programmer should know and understand.\n 

Now that we have been introduced to OOP, let's delve deeper. A class lays the groundwork for creating objects, which are instances of the class.\nA class defines a set of variables and methods that the objects created from it will have .\nMethods are class functions that can be called on objects to perform some action.\nWhen an object is created from a class, it is called an instance of that class.\nEach instance can have its own values for the attributes defined in the class.\nLet's explore an example about how classes work in python:\n\n#please take note of the indentation(indentation is very important in python)\nclass Student:\n  #this is a constructor which is a method that is called when an object is created/constructed\n  #self is just a pointer to the own specific object, don't worry about it too much\n  def __init__(self, name, age, major):\n    self.name = name\n    self.age = age \n    self.major = major  \n\n  #this is a method that displays my info\n  def getStudentInfo(self):\n    print('name:', self.name)\n    print('age:', self.age)\n    print('major:', self.major)\n\n\nVansh = Student('Vansh Nagpal',20,'Computer Science')\nVansh.getStudentInfo()#Output'Vansh Nagpal'\n20\n'Computer Science'

Inheritance and Polymorphism are the height of what one can achieve with OOP.\nInheritance allows you to declare a class that will act as the parent, and then declare a class that will act as the child.\nThe child class expands upon the capabilities of the parent, or 'inherits' the parent's capabilities.\nThis goes back to the concept of reusability in code.\nIf it is not necessary to write more code, then why should you?\nPolymorphism is a way for objects of different classes to implement certain capabilities in different ways.\nSpecificallyit refers to functions that child classes implement or override in different ways.\nHere is an example of both polymorphism and inheritance in python:\n\n#Here the cat and dog classes inherit from the animal class:\nclass Animal:\n  def __init__(self, name, age):\n    self.age = age\n    self.name = name\n\n  def makeASound(self)\n    print("this will be overriden")\n\n#dog is a child of animal, hence (Animal)\nclass Dog(Animal):\n  def __init(self, name, age, breed)\n    super().__init(name, age)#calls parent constructor\n    self.breed = breed\n\n  def makeASound(self):\n    print("BARK")\n\n#cat is a child of animal, hence (Animal)\nclass Cat(Animal):\n  def __init(self, name, age, color)\n    super().__init(name, age)#calls parent constructor\n    self.color = color\n\n  def makeASound(self):\n    print("MEOW MEOW")  \n\ndog = Dog('rex', 3,'golden retriever')\ncat = Cat('jenna', 2, 'black and white')\ndog.makeASound()#Output: BARK\ncat.makeASound()#Ouput: MEOW MEOW
